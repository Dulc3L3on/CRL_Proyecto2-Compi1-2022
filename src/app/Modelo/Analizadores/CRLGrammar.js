/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var CRLGrammar = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,17],$V1=[1,26],$V2=[1,14],$V3=[1,27],$V4=[1,28],$V5=[1,29],$V6=[1,30],$V7=[1,31],$V8=[1,25],$V9=[1,7],$Va=[1,35],$Vb=[1,36],$Vc=[1,34],$Vd=[1,42],$Ve=[1,54],$Vf=[1,55],$Vg=[1,56],$Vh=[1,57],$Vi=[1,58],$Vj=[1,59],$Vk=[1,60],$Vl=[1,61],$Vm=[1,49],$Vn=[1,50],$Vo=[1,51],$Vp=[1,52],$Vq=[2,5,8,14,15,18,33,34,35,36,37,43,107],$Vr=[8,15,33,34,35,36,37,43],$Vs=[5,8,15,33,34,35,36,37,43],$Vt=[8,14,15,18,33,34,35,36,37,43],$Vu=[1,69],$Vv=[1,90],$Vw=[1,87],$Vx=[1,73],$Vy=[1,79],$Vz=[1,81],$VA=[1,82],$VB=[1,83],$VC=[1,85],$VD=[1,88],$VE=[1,89],$VF=[1,97],$VG=[1,101],$VH=[2,15],$VI=[1,109],$VJ=[32,41,102,107],$VK=[1,116],$VL=[1,117],$VM=[2,60],$VN=[32,41,57,59,102,107],$VO=[1,118],$VP=[1,119],$VQ=[1,120],$VR=[32,41,57,59,60,62,63,102,107],$VS=[32,41,57,59,60,62,63,65,102,107],$VT=[1,123],$VU=[1,124],$VV=[1,125],$VW=[1,126],$VX=[1,127],$VY=[1,128],$VZ=[1,129],$V_=[32,41,57,59,60,62,63,65,67,69,70,71,72,73,74,102,107],$V$=[1,130],$V01=[32,41,57,59,60,62,63,65,67,69,70,71,72,73,74,75,102,107],$V11=[1,131],$V21=[32,41,57,59,60,62,63,65,67,69,70,71,72,73,74,75,77,102,107],$V31=[1,132],$V41=[32,41,57,59,60,62,63,65,67,69,70,71,72,73,74,75,77,79,102,107],$V51=[32,55,107],$V61=[2,29],$V71=[1,150],$V81=[1,176],$V91=[2,41],$Va1=[1,186],$Vb1=[32,41];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"inicio":3,"clase":4,"EOF":5,"nl":6,"class_elements":7,"SANGRIA":8,"header":9,"content":10,"imports":11,"incerteza":12,"import":13,"IMPORT":14,"ID":15,".":16,"CRL":17,"INCERTEZA":18,"expression":19,"sentences":20,"class_content":21,"function_content":22,"class_content_elements":23,"declaracion_var_global":24,"asignacion_var_global":25,"declaracion_funcion":26,"declaracion_var":27,"content_type":28,"creacion_vars":29,"asignation_value":30,"var_list":31,",":32,"INT":33,"DOUBLE":34,"STRING":35,"BOOLEAN":36,"CHAR":37,"asignacion_var":38,"(":39,"params":40,")":41,":":42,"VOID":43,"MAIN":44,"params_list":45,"param":46,"function_sentence":47,"only_sentence":48,"loop_sentence":49,"control_sentence":50,"invocacion":51,"mostrar":52,"dibujar":53,"breakpoints":54,"=":55,"expr":56,"+":57,"expr2":58,"-":59,"*":60,"expr3":61,"/":62,"%":63,"expr4":64,"^":65,"expr5":66,"==":67,"expr6":68,"!=":69,"<":70,">":71,"<=":72,">=":73,"~":74,"OR":75,"expr7":76,"XOR":77,"expr8":78,"&&":79,"expr9":80,"!":81,"expr10":82,"INTEGER":83,"DECIMAL":84,"CADENA":85,"booleano":86,"CHARACTER":87,"contenido_var":88,"TRUE":89,"FALSE":90,"argumentos":91,"MOSTRAR":92,"contenido_asignacion":93,"DRAW_AST":94,"DRAW_EXP":95,"DRAW_TS":96,"RETORNO":97,"CONTINUAR":98,"DETENER":99,"PARA":100,"for_var":101,";":102,"INCREMENTO":103,"MIENTRAS":104,"SI":105,"SINO":106,"NEW_LINE":107,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",8:"SANGRIA",14:"IMPORT",15:"ID",16:".",17:"CRL",18:"INCERTEZA",32:",",33:"INT",34:"DOUBLE",35:"STRING",36:"BOOLEAN",37:"CHAR",39:"(",41:")",42:":",43:"VOID",44:"MAIN",55:"=",57:"+",59:"-",60:"*",62:"/",63:"%",65:"^",67:"==",69:"!=",70:"<",71:">",72:"<=",73:">=",74:"~",75:"OR",77:"XOR",79:"&&",81:"!",83:"INTEGER",84:"DECIMAL",85:"CADENA",87:"CHARACTER",89:"TRUE",90:"FALSE",92:"MOSTRAR",94:"DRAW_AST",95:"DRAW_EXP",96:"DRAW_TS",97:"RETORNO",98:"CONTINUAR",99:"DETENER",100:"PARA",102:";",103:"INCREMENTO",104:"MIENTRAS",105:"SI",106:"SINO",107:"NEW_LINE"},
productions_: [0,[3,2],[4,2],[4,3],[4,1],[4,1],[7,2],[7,1],[9,2],[9,1],[9,1],[11,2],[11,1],[11,2],[13,5],[12,3],[10,2],[10,1],[20,1],[20,1],[21,2],[23,1],[23,1],[23,1],[24,1],[27,3],[27,2],[29,1],[31,3],[31,1],[31,2],[28,1],[28,1],[28,1],[28,1],[28,1],[25,1],[26,6],[26,6],[26,5],[40,1],[40,0],[45,3],[45,1],[45,2],[46,2],[22,3],[47,1],[47,1],[47,1],[47,1],[48,1],[48,1],[48,1],[48,1],[48,1],[48,1],[38,2],[30,2],[19,1],[19,1],[56,3],[56,3],[56,1],[58,3],[58,3],[58,3],[58,1],[61,3],[61,1],[64,2],[64,1],[66,3],[66,3],[66,3],[66,3],[66,3],[66,3],[66,3],[66,1],[68,3],[68,1],[76,3],[76,1],[78,3],[78,1],[80,2],[80,1],[82,1],[82,1],[82,1],[82,1],[82,1],[82,1],[82,3],[86,1],[86,1],[88,1],[88,1],[51,4],[51,3],[52,5],[93,2],[93,0],[93,1],[91,3],[91,1],[91,2],[53,4],[53,4],[53,3],[54,1],[54,2],[54,1],[54,1],[49,9],[49,5],[101,4],[50,5],[50,2],[6,2],[6,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 console.log("---Parser process terminated---");
                                            hierarchyStack.reduceStack();//puesto que si en dado caso la última función no tuviera como último elemento una directiva, la pila no sería reducida y con ello, los LC que se quedaron ahí olvidados no setearían padre y a la función no le serían seteados dichos LC como hijos, de todos modos si la pila estuviera vacía, no pasaría nada malo y tb si solo estuviera la función, pues tampoco sucedería algo malo, puesto que ella ya fuea asignada al contenido y tb ya tiene asignado a su respect clase padre xD                                            
                                            let claseFinal;
                                            console.log("---PRE---");
                                            console.log(claseFinal);
                                            console.log(clase);
                                            claseFinal = clase;                                            
                                            clase = new GlobalContainer();//para cuando se invoque de nuevo el método, así no hay problema con que esté seteando la info de otra clase aquí
                                            console.log("---POST---");
                                            console.log(claseFinal);
                                            console.log(clase);
                                                                                                                                  
                                            return claseFinal; 
break;
case 5:
 addParser_Error(ErrorType.SINTACTIC, _$[$0].first_line, _$[$0].first_column, yytext, ErrorMessage.CLASS_WITH_ERRORS); 
break;
case 6:
console.log("[S] Header + Content");
break;
case 7:
console.log("[S] Only Body");
break;
case 8:
console.log("[S] Header: Import + Incertitude");
break;
case 9:
console.log("[S] Header: Import");
break;
case 10:
console.log("[S] Header: Incertitude");
break;
case 11:
console.log("[S] Header: +1 import");
break;
case 12:
console.log("[S] Header: 1st import");
break;
case 13:
 addParser_Error(ErrorType.SINTACTIC, _$[$0-1].first_line, _$[$0-1].first_column, yytext, ErrorMessage.IMPORT_LIST_WITH_ERRORS); 
break;
case 14:
addImport(_$[$0-4].first_line, _$[$0-4].first_column, ($$[$0-3]+".crl"));
break;
case 15:
addIncertitude(_$[$0-2].first_line, _$[$0-2].first_column, $$[$0-1]);
break;
case 16:
console.log("[S] Content: +1 sentence");
break;
case 17:
console.log("[S] Content: 1st sentence");
break;
case 18:
console.log("[S] CLASS- content added");
break;
case 19:
console.log("[S] FUN- content added");
break;
case 21:
 addClassContent($$[$0], null, null); 
break;
case 22:
 addClassContent(null, null, $$[$0]); 
break;
case 23:
 addClassContent(null, $$[$0], null); 
break;
case 24:
console.log("[S] ClassC: "+ $$[$0].length +"GLOBAL var created");
                                                              this.$ = $$[$0]; 
break;
case 25:
 console.log("var_list-Dec "+ $$[$0-1]);
                                                                                       this.$ = createVarDeclaration(_$[$0-2].first_line, _$[$0-2].first_column, $$[$0-2], $$[$0-1], $$[$0]); 
break;
case 26:
 this.$ = createVarDeclaration(_$[$0-1].first_line, _$[$0-1].first_column, $$[$0-1], $$[$0], null); 
break;
case 27:
 this.$ = $$[$0];
                                                  console.log("var_list-crec "+this.$); 
break;
case 28:
 $$[$0-2].push($$[$0]); 
                                                  this.$ = $$[$0-2];
                                                  console.log("var_list "+this.$); 
break;
case 29:
 console.log("id-element_list "+$$[$0]);
                                                  this.$ = [yytext]; 
break;
case 30:
 addParser_Error(ErrorType.SINTACTIC, _$[$0-1].first_line, _$[$0-1].first_column, yytext, ErrorMessage.VARIABLE_LIST_WITH_ERRORS); 
break;
case 31:
 this.$ = ContentType.INTEGER; 
break;
case 32:
 this.$ = ContentType.DOUBLE; 
break;
case 33:
 this.$ = ContentType.STRING; 
break;
case 34:
 this.$ = ContentType.BOOLEAN; 
break;
case 35:
 this.$ = ContentType.CHAR; 
break;
case 36:
 console.log("[S] ClassC: "+ $$[$0].length +"GLOBAL asignation realized");
                                                              this.$ = $$[$0]; 
break;
case 37:
 this.$ = createFunction(_$[$0-5].first_line, _$[$0-5].first_column, "COMPLEX", $$[$0-5], $$[$0-4], $$[$0-2]); 
break;
case 38:
 this.$ = createFunction(_$[$0-5].first_line, _$[$0-5].first_column, "SIMPLE", $$[$0-5], $$[$0-4], $$[$0-2]); 
break;
case 39:
 this.$ = createFunction(_$[$0-4].first_line, _$[$0-4].first_column, "MAIN", $$[$0-4], $$[$0-3], []); 
break;
case 40: case 52: case 53: case 54: case 55: case 56: case 58: case 63: case 67: case 69: case 71: case 79: case 83: case 85: case 87: case 93: case 95: case 96: case 102:
 this.$ = $$[$0]; 
break;
case 41: case 103:
 this.$ = []; 
break;
case 42:
 $$[$0-2].push($$[$0]); 
                                                        this.$ = $$[$0-2];
                                                        console.log("param_list "+this.$); 
break;
case 43:
 this.$ = [];                                                        
                                                        this.$.push($$[$0]);
                                                        console.log("element_param_list "+this.$); 
break;
case 44:
 addParser_Error(ErrorType.SINTACTIC, _$[$0-1].first_line, _$[$0-1].first_column, yytext, ErrorMessage.PARAM_LIST_WITH_ERRORS); 
break;
case 45:
 this.$ = createParam(_$[$0].first_line, _$[$0].first_column, $$[$0-1], $$[$0]); 
break;
case 46:
 addFunctionContent(getHierarchy($$[$0-2]), $$[$0-1]); 
break;
case 47:
 isADirective = true;
                                                          this.$ = $$[$0]; 
break;
case 48: case 49:
 isADirective = false;
                                                          this.$ = $$[$0]; 
break;
case 50:
 addParser_Error(ErrorType.SINTACTIC, _$[$0].first_line, _$[$0].first_column, yytext, ErrorMessage.FUNCTION_ELEMENTS_WITH_ERRORS); 
break;
case 51:
 isAVariableDeclaration = true;//Esto lo coloco pues es el único contenido de una función que puede ser una lista, por lo cual debe ser tratado de manera diferente
                                                        this.$ = $$[$0]; 
break;
case 57:
 this.$ = createAsignation(_$[$0-1].first_line, _$[$0-1].first_column, $$[$0-1], $$[$0]); 
break;
case 59:
 this.$ = $$[$0];
                                            console.log("expresión "+this.$); 
break;
case 60:
 addParser_Error(ErrorType.SINTACTIC, _$[$0].first_line, _$[$0].first_column, yytext, ErrorMessage.EXPRESSION_ERRATE); 
break;
case 61: case 62: case 64: case 65: case 66:
 this.$ = createExpr_Operation(_$[$0-1].first_line, _$[$0-1].first_column, OperatorType.ARITMETIC, $$[$0-2], $$[$0-1], $$[$0]); 
break;
case 68:
 this.$ = createExpr_Operation(_$[$0-1].first_line, _$[$0-1].first_column, OperatorType.ARITMETIC, $$[$0-2],$$[$0-1], $$[$0]); 
break;
case 70:
 let expre = new Expresion(_$[$0-1].first_line, _$[$0-1].first_column, null, 0, null);
                                                        expre.getValue();//pienso que esto está de más, porque de todos modos lo que pasaría es que primero revisaría sus hijos, es decir el 0 y el valor a negar, exe esta función y luego lo de la resta. Pero si queires dejala aquí, no provocará algo malo, solo que se hará un mini trabajo extra xD, esto lo digo porque recuerda que caerá a la misma RP que de la resta, entonces no se req hacer este getValueo xD
                                                        this.$ = createExpr_Operation(_$[$0-1].first_line, _$[$0-1].first_column, OperatorType.ARITMETIC, expre, $$[$0-1], $$[$0]); 
break;
case 72: case 73: case 74: case 75: case 76: case 77: case 78:
 this.$ = createExpr_Operation(_$[$0-1].first_line, _$[$0-1].first_column, OperatorType.RELATIONAL, $$[$0-2], $$[$0-1], $$[$0]); 
break;
case 80: case 84:
 this.$ = createExpr_Operation(_$[$0-1].first_line, _$[$0-1].first_column, OperatorType.LOGIC, $$[$0-2], $$[$0-1], $$[$0]); 
break;
case 81:
 this.$ =  $$[$0]; 
break;
case 82:
 this.$ = createExpr_Operation(_$[$0-1].first_line, _$[$0-1].first_column, OperatorType.LOGIC, $$[$0-2], $$[$0-1], $$[$0]); 
                                                   console.log("XOR "+$$[$0-1]);
break;
case 86:
 this.$ = createExpr_Operation(_$[$0-1].first_line, _$[$0-1].first_column, OperatorType.LOGIC, null, $$[$0], $$[$01]); 
break;
case 88:
 this.$ = createExpr_Value(_$[$0].first_line, _$[$0].first_column, "INTEGER", $$[$0]); 
break;
case 89:
 this.$ = createExpr_Value(_$[$0].first_line, _$[$0].first_column, "DECIMAL", $$[$0]); 
break;
case 90:
 this.$ = createExpr_Value(_$[$0].first_line, _$[$0].first_column, "CADENA", $$[$0]); 
break;
case 91:
 this.$ = createExpr_Value(_$[$0].first_line, _$[$0].first_column, "BOOLEAN", $$[$0]); 
break;
case 92:
 this.$ = createExpr_Value(_$[$0].first_line, _$[$0].first_column, "CHARACTER", $$[$0]); 
break;
case 94:
 this.$ = createExpr_Operation(_$[$0-2].first_line, _$[$0-2].first_column, OperatorType.AGRUP, $$[$0-1], "()", null); 
break;
case 97:
 this.$ = createExpr_Value(_$[$0].first_line, _$[$0].first_column, "VARIABLE", $$[$0]); 
break;
case 98:
 $$[$0].setIsOnlyInvocated(false);//puesto que si vino aquí, pues no lo es xD
                                      this.$ = createExpr_Value(_$[$0].first_line, _$[$0].first_column, "INVOCACION", $$[$0]); 
break;
case 99:
 this.$ = createInvocation(_$[$0-3].first_line, _$[$0-3].first_column, $$[$0-3], $$[$0-1]); 
break;
case 100:
 this.$ = createInvocation(_$[$0-2].first_line, _$[$0-2].first_column, $$[$0-2], []); 
break;
case 101:
 this.$ = createMostrar(_$[$0-4].first_line, _$[$0-4].first_column, $$[$0-2], $$[$0-1]); 
break;
case 104:
 addParser_Error(ErrorType.SINTACTIC, _$[$0].first_line, _$[$0].first_column, yytext, ErrorMessage.ASIGNATED_SHOW_CONTENT_WITH_ERRORS); 
break;
case 105:
 $$[$0-2].push($$[$0]); 
                                                              this.$ = $$[$0-2]; 
                                                              console.log("argu_list "+this.$);
                                                              isAList = true; 
break;
case 106:
 this.$ = [];
                                                              this.$.push($$[$0]);
                                                              console.log("element_argu_list "+this.$);
                                                              isAList = false; 
break;
case 107:
 addParser_Error(ErrorType.SINTACTIC, _$[$0-1].first_line, _$[$0-1].first_column, yytext, ErrorMessage.ARGUMENT_LIST_WITH_ERRORS); 
break;
case 108:
 this.$ = createDraw_AST(_$[$0-3].first_line, _$[$0-3].first_column, $$[$0-1]); 
break;
case 109:
 this.$ = createDraw_EXP(_$[$0-3].first_line, _$[$0-3].first_column, $$[$0-1]); 
break;
case 110:
 this.$ = createDraw_TS(_$[$0-2].first_line, _$[$0-2].first_column, ); 
break;
case 111:
 this.$ = createBreakPoint(_$[$0].first_line, _$[$0].first_column, "RETURN", null); 
break;
case 112:
 this.$ = createBreakPoint(_$[$0-1].first_line, _$[$0-1].first_column, "RETURN", $$[$0]); 
break;
case 113:
 this.$ = createBreakPoint(_$[$0].first_line, _$[$0].first_column, "CONTINUE", null); 
break;
case 114:
 this.$ = createBreakPoint(_$[$0].first_line, _$[$0].first_column, "BREAK", null); 
break;
case 115:
 this.$ = createFor(_$[$0-8].first_line, _$[$0-8].first_column, $$[$0-6], $$[$0-4], $$[$0-2]); 
break;
case 116:
 this.$ = createWhile(_$[$0-4].first_line, _$[$0-4].first_column, $$[$0-2]); 
break;
case 117:
 this.$ = createForVar(_$[$0-2].first_line, _$[$0-2].first_column, $$[$0-2], $$[$0]); 
break;
case 118:
 this.$ = createControl_Sentence(_$[$0-4].first_line, _$[$0-4].first_column, $$[$0-2]); 
break;
case 119:
 this.$ = createControl_Sentence(_$[$0-1].first_line, _$[$0-1].first_column, null); 
break;
}
},
table: [{2:[1,6],3:1,4:2,6:3,7:5,8:[1,4],9:8,10:9,11:10,12:11,13:13,14:$V0,15:$V1,18:$V2,20:12,21:15,22:16,23:18,24:19,25:20,26:21,27:22,28:24,33:$V3,34:$V4,35:$V5,36:$V6,37:$V7,38:23,43:$V8,107:$V9},{1:[3]},{5:[1,32]},{2:$Va,7:33,8:$Vb,9:8,10:9,11:10,12:11,13:13,14:$V0,15:$V1,18:$V2,20:12,21:15,22:16,23:18,24:19,25:20,26:21,27:22,28:24,33:$V3,34:$V4,35:$V5,36:$V6,37:$V7,38:23,43:$V8,107:$Vc},{2:$Vd,6:37,15:$Ve,27:43,28:53,33:$V3,34:$V4,35:$V5,36:$V6,37:$V7,38:44,47:38,48:39,49:40,50:41,51:45,52:46,53:47,54:48,92:$Vf,94:$Vg,95:$Vh,96:$Vi,97:$Vj,98:$Vk,99:$Vl,100:$Vm,104:$Vn,105:$Vo,106:$Vp,107:$V9},{5:[2,4]},{5:[2,5],13:62,14:$V0},o($Vq,[2,121]),{8:$Vb,10:63,15:$V1,20:12,21:15,22:16,23:18,24:19,25:20,26:21,27:22,28:24,33:$V3,34:$V4,35:$V5,36:$V6,37:$V7,38:23,43:$V8},{5:[2,7],8:$Vb,15:$V1,20:64,21:15,22:16,23:18,24:19,25:20,26:21,27:22,28:24,33:$V3,34:$V4,35:$V5,36:$V6,37:$V7,38:23,43:$V8},o($Vr,[2,9],{12:65,13:66,14:$V0,18:$V2}),o($Vr,[2,10]),o($Vs,[2,17]),o($Vt,[2,12]),{2:$Vu,15:$Vv,19:67,39:$Vw,51:91,56:68,58:70,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},o($Vs,[2,18]),o($Vs,[2,19]),{15:[1,92]},{6:93,107:$V9},{107:[2,21]},{107:[2,22]},{107:[2,23]},{107:[2,24]},{107:[2,36]},{2:$VF,15:[1,94],29:95,31:96},{15:[1,98],44:[1,99]},{30:100,55:$VG},o($VH,[2,31]),o($VH,[2,32]),o($VH,[2,33]),o($VH,[2,34]),o($VH,[2,35]),{1:[2,1]},{5:[2,2]},o($Vq,[2,120]),{13:62,14:$V0},{2:$Vd,15:$Ve,27:43,28:53,33:$V3,34:$V4,35:$V5,36:$V6,37:$V7,38:44,47:38,48:39,49:40,50:41,51:45,52:46,53:47,54:48,92:$Vf,94:$Vg,95:$Vh,96:$Vi,97:$Vj,98:$Vk,99:$Vl,100:$Vm,104:$Vn,105:$Vo,106:$Vp},{2:$Va,7:102,8:$Vb,9:8,10:9,11:10,12:11,13:13,14:$V0,15:$V1,18:$V2,20:12,21:15,22:16,23:18,24:19,25:20,26:21,27:22,28:24,33:$V3,34:$V4,35:$V5,36:$V6,37:$V7,38:23,43:$V8,107:$Vc},{6:103,107:$V9},{107:[2,47]},{107:[2,48]},{107:[2,49]},{107:[2,50]},{107:[2,51]},{107:[2,52]},{107:[2,53]},{107:[2,54]},{107:[2,55]},{107:[2,56]},{39:[1,104]},{39:[1,105]},{39:[1,106]},{42:[1,107]},{2:$VF,15:[1,108],29:95,31:96},{30:100,39:$VI,55:$VG},{39:[1,110]},{39:[1,111]},{39:[1,112]},{39:[1,113]},{2:$Vu,15:$Vv,19:114,39:$Vw,51:91,56:68,58:70,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE,107:[2,111]},{107:[2,113]},{107:[2,114]},o($Vt,[2,13]),{5:[2,6],8:$Vb,15:$V1,20:64,21:15,22:16,23:18,24:19,25:20,26:21,27:22,28:24,33:$V3,34:$V4,35:$V5,36:$V6,37:$V7,38:23,43:$V8},o($Vs,[2,16]),o($Vr,[2,8]),o($Vt,[2,11]),{6:115,107:$V9},o($VJ,[2,59],{57:$VK,59:$VL}),o($VJ,$VM),o($VN,[2,63],{60:$VO,62:$VP,63:$VQ}),o($VR,[2,67]),o($VR,[2,69],{65:[1,121]}),{15:$Vv,39:$Vw,51:91,66:122,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},o($VS,[2,71],{67:$VT,69:$VU,70:$VV,71:$VW,72:$VX,73:$VY,74:$VZ}),o($V_,[2,79],{75:$V$}),o($V01,[2,81],{77:$V11}),o($V21,[2,83],{79:$V31}),o($V41,[2,85]),{15:$Vv,39:$Vw,51:91,82:133,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},o($V41,[2,87]),o($V41,[2,88]),o($V41,[2,89]),o($V41,[2,90]),o($V41,[2,91]),o($V41,[2,92]),o($V41,[2,93]),{15:$Vv,39:$Vw,51:91,56:134,58:70,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},o($V41,[2,95]),o($V41,[2,96]),o($V41,[2,97],{39:$VI}),o($V41,[2,98]),{16:[1,135]},o($Vs,[2,20],{107:$Vc}),o($V51,$V61,{39:[1,136]}),{30:137,55:$VG,107:[2,26]},o([55,107],[2,27],{32:[1,138]}),{15:[1,139]},{39:[1,140]},{39:[1,141]},{107:[2,57]},{2:$Vu,15:$Vv,19:142,39:$Vw,51:91,56:68,58:70,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{5:[2,3]},o($Vs,[2,46],{107:$Vc}),{33:[1,144],101:143},{2:$Vu,15:$Vv,19:145,39:$Vw,51:91,56:68,58:70,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{2:$Vu,15:$Vv,19:146,39:$Vw,51:91,56:68,58:70,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{107:[2,119]},o($V51,$V61),{2:$V71,15:$Vv,19:149,39:$Vw,41:[1,148],51:91,56:68,58:70,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE,91:147},{85:[1,151]},{15:[1,152]},{2:$Vu,15:$Vv,19:153,39:$Vw,51:91,56:68,58:70,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{41:[1,154]},{107:[2,112]},o($Vr,$VH,{107:$Vc}),{15:$Vv,39:$Vw,51:91,58:155,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,58:156,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,59:$Vx,61:157,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,59:$Vx,61:158,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,59:$Vx,61:159,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,59:$Vx,61:160,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},o($VS,[2,70],{67:$VT,69:$VU,70:$VV,71:$VW,72:$VX,73:$VY,74:$VZ}),{15:$Vv,39:$Vw,51:91,68:161,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,68:162,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,68:163,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,68:164,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,68:165,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,68:166,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,68:167,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,76:168,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,78:169,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{15:$Vv,39:$Vw,51:91,80:170,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},o($V41,[2,86]),{41:[1,171],57:$VK,59:$VL},{17:[1,172]},{2:$V81,28:177,33:$V3,34:$V4,35:$V5,36:$V6,37:$V7,40:173,41:$V91,45:174,46:175},{107:[2,25]},{15:[1,178]},o($V51,[2,30]),{2:$V81,28:177,33:$V3,34:$V4,35:$V5,36:$V6,37:$V7,40:179,41:$V91,45:174,46:175},{41:[1,180]},{107:[2,58]},{102:[1,181]},{15:[1,182]},{41:[1,183]},{41:[1,184]},{32:$Va1,41:[1,185]},o($V41,[2,100]),o($Vb1,[2,106]),o($Vb1,$VM,{56:68,58:70,61:71,64:72,66:74,68:75,76:76,78:77,80:78,82:80,86:84,88:86,51:91,19:187,2:$Vu,15:$Vv,39:$Vw,59:$Vx,81:$Vy,83:$Vz,84:$VA,85:$VB,87:$VC,89:$VD,90:$VE}),{2:[1,190],32:[1,189],41:[2,103],93:188},{41:[1,191]},{41:[1,192]},{107:[2,110]},o($VN,[2,61],{60:$VO,62:$VP,63:$VQ}),o($VN,[2,62],{60:$VO,62:$VP,63:$VQ}),o($VR,[2,64]),o($VR,[2,65]),o($VR,[2,66]),o($VR,[2,68]),o($V_,[2,72],{75:$V$}),o($V_,[2,73],{75:$V$}),o($V_,[2,74],{75:$V$}),o($V_,[2,75],{75:$V$}),o($V_,[2,76],{75:$V$}),o($V_,[2,77],{75:$V$}),o($V_,[2,78],{75:$V$}),o($V01,[2,80],{77:$V11}),o($V21,[2,82],{79:$V31}),o($V41,[2,84]),o($V41,[2,94]),{6:193,107:$V9},{41:[1,194]},{32:[1,195],41:[2,40]},o($Vb1,[2,43]),{28:177,33:$V3,34:$V4,35:$V5,36:$V6,37:$V7,46:196},{15:[1,197]},o($V51,[2,28]),{41:[1,198]},{42:[1,199]},{2:$Vu,15:$Vv,19:200,39:$Vw,51:91,56:68,58:70,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},{55:[1,201]},{42:[1,202]},{42:[1,203]},o($V41,[2,99]),{2:$Vu,15:$Vv,19:204,39:$Vw,51:91,56:68,58:70,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE},o($Vb1,[2,107]),{41:[1,205]},{2:$V71,15:$Vv,19:149,39:$Vw,51:91,56:68,58:70,59:$Vx,61:71,64:72,66:74,68:75,76:76,78:77,80:78,81:$Vy,82:80,83:$Vz,84:$VA,85:$VB,86:84,87:$VC,88:86,89:$VD,90:$VE,91:206},{41:[2,104]},{107:[2,108]},{107:[2,109]},o($Vt,[2,14],{107:$Vc}),{42:[1,207]},{28:177,33:$V3,34:$V4,35:$V5,36:$V6,37:$V7,46:208},o($Vb1,[2,44]),o($Vb1,[2,45]),{42:[1,209]},{107:[2,39]},{102:[1,210]},{83:[1,211]},{107:[2,116]},{107:[2,118]},o($Vb1,[2,105]),{107:[2,101]},{32:$Va1,41:[2,102]},{107:[2,37]},o($Vb1,[2,42]),{107:[2,38]},{103:[1,212]},{102:[2,117]},{41:[1,213]},{42:[1,214]},{107:[2,115]}],
defaultActions: {5:[2,4],19:[2,21],20:[2,22],21:[2,23],22:[2,24],23:[2,36],32:[2,1],33:[2,2],39:[2,47],40:[2,48],41:[2,49],42:[2,50],43:[2,51],44:[2,52],45:[2,53],46:[2,54],47:[2,55],48:[2,56],60:[2,113],61:[2,114],100:[2,57],102:[2,3],107:[2,119],114:[2,112],137:[2,25],142:[2,58],154:[2,110],190:[2,104],191:[2,108],192:[2,109],199:[2,39],202:[2,116],203:[2,118],205:[2,101],207:[2,37],209:[2,38],211:[2,117],214:[2,115]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse (input) {
    var self = this,
        stack = [0],
        tstack = [], // token stack
        vstack = [null], // semantic value stack
        lstack = [], // location stack
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;

    var args = lstack.slice.call(arguments, 1);

    //this.reductionCount = this.shiftCount = 0;

    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    // copy state
    for (var k in this.yy) {
      if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
        sharedState.yy[k] = this.yy[k];
      }
    }

    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);

    var ranges = lexer.options && lexer.options.ranges;

    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }

    function popStack (n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }

_token_stack:
    var lex = function () {
        var token;
        token = lexer.lex() || EOF;
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    }

    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        // retreive state number from top of stack
        state = stack[stack.length - 1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            // read action for current state and first input
            action = table[state] && table[state][symbol];
        }

_handle_error:
        // handle parse error
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var error_rule_depth;
            var errStr = '';

            // Return the rule stack depth where the nearest error rule can be found.
            // Return FALSE when no error recovery rule was found.
            function locateNearestErrorRecoveryRule(state) {
                var stack_probe = stack.length - 1;
                var depth = 0;

                // try to recover from error
                for(;;) {
                    // check for error recovery rule in this state
                    if ((TERROR.toString()) in table[state]) {
                        return depth;
                    }
                    if (state === 0 || stack_probe < 2) {
                        return false; // No suitable error recovery rule available.
                    }
                    stack_probe -= 2; // popStack(1): [symbol, action]
                    state = stack[stack_probe];
                    ++depth;
                }
            }

            if (!recovering) {
                // first see if there's any chance at hitting an error recovery rule:
                error_rule_depth = locateNearestErrorRecoveryRule(state);

                // Report error
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push("'"+this.terminals_[p]+"'");
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line '+(yylineno+1)+":\n"+lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + (this.terminals_[symbol] || symbol)+ "'";
                } else {
                    errStr = 'Parse error on line '+(yylineno+1)+": Unexpected " +
                                  (symbol == EOF ? "end of input" :
                                              ("'"+(this.terminals_[symbol] || symbol)+"'"));
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected,
                    recoverable: (error_rule_depth !== false)
                });
            } else if (preErrorSymbol !== EOF) {
                error_rule_depth = locateNearestErrorRecoveryRule(state);
            }

            // just recovered from another error
            if (recovering == 3) {
                if (symbol === EOF || preErrorSymbol === EOF) {
                    throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
                }

                // discard current lookahead and grab another
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                symbol = lex();
            }

            // try to recover from error
            if (error_rule_depth === false) {
                throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
            }
            popStack(error_rule_depth);

            preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token
            symbol = TERROR;         // insert generic error symbol as new lookahead
            state = stack[stack.length-1];
            action = table[state] && table[state][TERROR];
            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
        }

        // this shouldn't happen, unless resolve defaults are off
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);
        }

        switch (action[0]) {
            case 1: // shift
                //this.shiftCount++;

                stack.push(symbol);
                vstack.push(lexer.yytext);
                lstack.push(lexer.yylloc);
                stack.push(action[1]); // push state
                symbol = null;
                if (!preErrorSymbol) { // normal execution/no error
                    yyleng = lexer.yyleng;
                    yytext = lexer.yytext;
                    yylineno = lexer.yylineno;
                    yyloc = lexer.yylloc;
                    if (recovering > 0) {
                        recovering--;
                    }
                } else {
                    // error just occurred, resume old lookahead f/ before error
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;

            case 2:
                // reduce
                //this.reductionCount++;

                len = this.productions_[action[1]][1];

                // perform semantic action
                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1
                // default location, uses first token for firsts, last for lasts
                yyval._$ = {
                    first_line: lstack[lstack.length-(len||1)].first_line,
                    last_line: lstack[lstack.length-1].last_line,
                    first_column: lstack[lstack.length-(len||1)].first_column,
                    last_column: lstack[lstack.length-1].last_column
                };
                if (ranges) {
                  yyval._$.range = [lstack[lstack.length-(len||1)].range[0], lstack[lstack.length-1].range[1]];
                }
                r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

                if (typeof r !== 'undefined') {
                    return r;
                }

                // pop off stack
                if (len) {
                    stack = stack.slice(0,-1*len*2);
                    vstack = vstack.slice(0, -1*len);
                    lstack = lstack.slice(0, -1*len);
                }

                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[stack[stack.length-2]][stack[stack.length-1]];
                stack.push(newState);
                break;

            case 3:
                // accept
                return true;
        }

    }

    return true;
}};
      
      const {HierarchyStack} = require("../Prev-Ejecucion/HierarchyStack.ts");
      const {ActiveFileHandler} = require("../Handlers/ActiveFileHandler.ts");  
      const {ErrorHandler} = require("../Handlers/ErrorHandler.ts");
      const {Error} = require("../Tool/Error/Error.ts");
      const {ErrorMessage} = require("../Tool/Error/ErrorMessage.ts");
      const {ErrorType} = require("../Tool/Error/ErrorType.ts");     
      const {SourceLocation} = require("../Tool/SourceLocation.ts");
      
      const {Import} = require("../ObjetosAnalisis/Sentences/Class_Content/Import.ts");      
      const {Incertitude} = require("../ObjetosAnalisis/Sentences/Class_Content/Incertitude.ts");

      const {Sentence} = require("../ObjetosAnalisis/Sentences/Sentence.ts");
      //const {Container} = require("../ObjetosAnalisis/Sentences/Container.ts");
      const {GlobalContainer} = require("../ObjetosAnalisis/Sentences/GlobalContainer.ts");      
      const {LocalContainer} = require("../ObjetosAnalisis/Sentences/LocalContainer.ts");
      const {Directive} = require("../ObjetosAnalisis/Sentences/Directive.ts");      

      const {Variable_Declaration} = require("../ObjetosAnalisis/Sentences/Variable_Declaration.ts");
      const {Function} = require("../ObjetosAnalisis/Sentences/Class_Content/Function.ts");

      const {Main} = require("../ObjetosAnalisis/Sentences/Class_Content/Main.ts");
      const {Complex_Function} = require("../ObjetosAnalisis/Sentences/Class_Content/Complex_Function.ts");
      const {Void_Function} = require("../ObjetosAnalisis/Sentences/Class_Content/Void_Function.ts");

      const {Control_Sentence} = require("../ObjetosAnalisis/Sentences/Function_Content/Control_Sentences/Control_Sentence.ts");
      const {If} = require("../ObjetosAnalisis/Sentences/Function_Content/Control_Sentences/If.ts");
      const {Else} = require("../ObjetosAnalisis/Sentences/Function_Content/Control_Sentences/Else.ts");

      const {Loop} = require("../ObjetosAnalisis/Sentences/Function_Content/Loops_Sentences/Loop.ts");
      const {For} = require("../ObjetosAnalisis/Sentences/Function_Content/Loops_Sentences/For.ts");
      const {While} = require("../ObjetosAnalisis/Sentences/Function_Content/Loops_Sentences/While.ts");      

      const {Breakpoint} = require("../ObjetosAnalisis/Sentences/Function_Content/Only_Sentences/Breakpoints/BreakPoint.ts");
      const {Break} = require("../ObjetosAnalisis/Sentences/Function_Content/Only_Sentences/Breakpoints/Break.ts");
      const {Continue} = require("../ObjetosAnalisis/Sentences/Function_Content/Only_Sentences/Breakpoints/Continue.ts");
      const {Return} = require("../ObjetosAnalisis/Sentences/Function_Content/Only_Sentences/Breakpoints/Return.ts");      

      const {Dibujar} = require("../ObjetosAnalisis/Sentences/Function_Content/Only_Sentences/Dibujar/Dibujar.ts");
      const {DibujarAST} = require("../ObjetosAnalisis/Sentences/Function_Content/Only_Sentences/Dibujar/DibujarAST.ts");
      const {DibujarEXP} = require("../ObjetosAnalisis/Sentences/Function_Content/Only_Sentences/Dibujar/DibujarEXP.ts");
      const {DibujarTS} = require("../ObjetosAnalisis/Sentences/Function_Content/Only_Sentences/Dibujar/DIbujarTS.ts");

      const {Asignacion} = require("../ObjetosAnalisis/Sentences/Function_Content/Only_Sentences/Asignacion.ts");
      const {Mostrar} = require("../ObjetosAnalisis/Sentences/Function_Content/Only_Sentences/Mostrar.ts");

      const {Expresion} = require("../ObjetosAnalisis/Sentences/Function_Content/Content/Expresion.ts");
      const {ContentType} = require("../ObjetosAnalisis/Sentences/Class_Content/ContentType.ts");
      const {Invocacion} = require("../ObjetosAnalisis/Sentences/Function_Content/Content/Invocacion.ts");      
      const {Variable} = require("../ObjetosAnalisis/Sentences/Function_Content/Content/Variable.ts");      
      const {Result} = require("../ObjetosAnalisis/Sentences/Function_Content/Content/Result.ts");
      const {OperationHandler} = require("../ObjetosAnalisis/Sentences/Function_Content/Content/OperationHandler.ts");
      const {Operator} = require("../ObjetosAnalisis/Sentences/Function_Content/Content/Operator.ts");
      const {OperatorType} = require("../ObjetosAnalisis/Sentences/Function_Content/Content/OperatorType.ts");
      const {OperatorResult} = require("../ObjetosAnalisis/Sentences/Function_Content/Content/OperationResult.ts");
      const {AddResult} = require("../ObjetosAnalisis/Sentences/Function_Content/Content/AddResult.ts");

      let lexer_error= "";      
      let clase = new GlobalContainer();//puesto que aquí se van a setear todos los obj creados      

      let activeFileHandler = ActiveFileHandler.getInstance();     
      let errorHandler = ErrorHandler.getInstance(); 

      let hierarchyStack = new HierarchyStack();
      let isADirective;
      let isAVariableDeclaration;
      let isAList;//Esta es solo para dar un msje más informativo al momento consolear xD el objeto creado      

      var varList = [];

   //HEADERS
      function addImport(line, column, importClassName){
            if(activeFileHandler.isExistFile(importClassName)){
                  if(!activeFileHandler.isMainFile(importClassName)){
                        console.log("[S] Header content: IMPORT [ "+ importClassName+" ]");
                        clase.addImport(new Import(line, column, importClassName));
                  }else{
                        //Se add el error, puesto que el archivo Main no tendría porque poder importarse, ya que eso no impediría que se pudiera invocar el método Main de nuevo, y así provocar un error por quedarse enciclado...
                        errorHandler.addMessage(new Error(ErrorType.SEMANTIC, ErrorMessage.IMPORT_NOT_ALLOWED,
                            new SourceLocation((line == undefined)?0:line, (column == undefined)?0:column), "IMPORT", clase.getName()));
                  }                  
            }else{
                  errorHandler.addMessage(new Error(ErrorType.SEMANTIC, ErrorMessage.INEXISTENT_IMPORTED_FILE,
                     new SourceLocation(line, column), "IMPORT", clase.getName()));
                  //Se add el error al manejador de errores, el cual se encarga de llevar el conteo y addlos de una vez a la consola...
            }            
      }

      function addIncertitude(line, column, expression){
            //Simplemente se debe crear el obj y addlo al globalContent (lo cual se puede hacer sin problema, pruesto que para que pudiera ser seteada al contenido se hizo que heredara de Directive...), puesto que la revisión profunda [con respecto a la exp], se hace en la clase Incert...
            console.log("[S] Header content: INCERTITUDE "+expression);
            let incertitude = new Incertitude(line, column, expression);
            incertitude.setFather(clase);
            clase.addGlobalContent(incertitude);
      }

  //CLASS CONTENT

      function getHierarchy(sangria){
            let lexema = sangria.split("");//sangria.charAt();//si no funciona usa split y "" nada xD
            console.log("[S] Hierarchy [SANGRIA]: "+lexema.length);

            return lexema.length;
      }

      function addClassContent(declaratedVars, theFunction, asignation){
            if(asignation != null){
                  hierarchyStack.reduceStack();//se hace aquí puesto que el for es para add cada var que se colocó en una misma línea de creación
                                      
                  asignation.setScope(0);
                  console.log("seteo el scope en asignation global");
                  asignation.setFather(clase);
                  clase.addGlobalContent(asignation);
                  
                  console.log("[S] Class content: VAR ASIGNATION");                  
            }else{
                  if(theFunction == null){//no reviso si el listado está vacío, porque bien podría ser que el dato que se envió fue el de una declaración, pero que... iba a decir que no contenga vars, pero en ese caso tendría que haber sucedido un error para que llegue vacía la lista...
                        hierarchyStack.reduceStack();//se hace aquí puesto que el for es para add cada var que se colocó en una misma línea de creación

                        for(let index = 0; index < declaratedVars.length; index++){                        
                              declaratedVars[index].setScope(0);
                              console.log("seteo el scope en var global");
                              declaratedVars[index].setFather(clase);
                              clase.addGlobalContent(declaratedVars[index]);
                        }
                        console.log("[S] Class content: VAR DECLARATION");                  
                  }else{
                        //la función ya tiene por defecto scope = 0, entonces no hay que hacer eso aquí
                        //tb ya tiene seteado su respectivo padre xD
                        clase.addGlobalContent(theFunction);//que se quede, puesto que encaja con las axn del stack xD                  
                        hierarchyStack.addFunction(theFunction);

                        console.log(theFunction);
                        console.log("[S] Class content: FUNCTION");                  
                  }
            }
            
      }//por la RP que contiene ambos tipos de contenido, se me ocurrió que quizá podría hacer el seteo de cada contenido, por medio de difernetes métodos, además como el proceso de seteo varía, puesto que en uno va directo al padre y en el otro directo a la func que está al ini de la pila o dir a la pila, entonces... xD      

      function addFunctionContent(scope, content){            
            console.log("content ");
            console.log(content);
            console.log("scope "+scope);            

            if(isADirective){           
                  if(isAVariableDeclaration){
                        for(let index = 0; index < content.length; index++){
                              content[index].setScope(scope);
                              console.log("content name: " + content[index].getSentenceName());
                              hierarchyStack.addLocalDirective(content[index]);
                              console.log("[S] Function content: SANGRIA [ directive on "+scope +" level]");
                        }

                        isAVariableDeclaration = false;//sino provocará problemas xD
                  }else{
                        content.setScope(scope);
                        console.log("content name: " + content.getSentenceName());
                        hierarchyStack.addLocalDirective(content);
                        console.log("[S] Function content: SANGRIA [ directive on "+scope +" level]");
                  }                  
            }else{
                  content.setScope(scope);                  
                  console.log("content name: " + content.getSentenceName());
                  hierarchyStack.addLocalContainer(content);
                  console.log("[S] Function content: SANGRIA [ sentence on "+scope +" level]");
            }//no tengo que resetear la var isADirective, puesto que no se va a llegar a la RP que invoca a este método, sin haber caido en la axn que setea esta var xD
      }

      function createVarDeclaration(line, column, type, varList, asignatedValue){//Este último puede ser null, puesto que no es obligatorio que especifiquen este valor...
            let declaratedVars = [];//new Array<Variable_Declaration>()
            console.log("list size "+varList.length);

            for(let index = 0; index < varList.length; index++){
                  declaratedVars.push(new Variable_Declaration(line, column, type, varList[index], asignatedValue));
            }

            console.log("[S] (G/L) content: DECLARATION [ "+((varList.length>0)?"var list":"var")+((asignatedValue != null)?" + expr":"")+ " ]");
            return declaratedVars;//pongo G/L, puesto que esta se usa para un decl en general, no para un tipo de decl en específico
      }//sin importar que sea G o L, puesto que esto se determina en prod más arriba de la RP en donde se crea el obj xD      

      function createFunction(line, column, functionType, returnType, name, params){
            switch(functionType){
                  case "SIMPLE":
                        console.log("[S] Global content: S_FUNCTION [ "+returnType +", " + name + ((params.length>0)?", params":"")+" ]");
                        return new Void_Function(line, column, clase, returnType, name, params);
                  case "COMPLEX":
                        console.log("[S] Global content: C_FUNCTION [ "+returnType +", " + name + ((params.length>0)?", params":"")+" ]");
                        return new Complex_Function(line, column, clase, returnType, name, params);
                  case "MAIN":
                        console.log("[S] Global content: MAIN [ "+returnType +", "+name+" ]");
                        return new Main(line, column, clase);
            }
            return null;//pero nunca se va a caer acá...
      }//LISTO

      function createParam(line, column, type, name){
            console.log("[S] Function sub-content: PARAM ["+type+", "+name+"]");
            return new Variable(line, column, type, name);
      }      

 //FUNCTION CONTENT

      function createAsignation(line, column, name, expr){
            console.log("[S] Function content: ASIGNATION [ "+name+" + expr ]");
            return new Asignacion(line, column, name, expr);
      }

   //EXPRESSIONS
      function createExpr_Operation(line, column, operationType, left, symbol, right){//ya sea la root o no
            console.log("[S] Function content: EXPR-OPERATION [ "+symbol+" ]");
            return new Expresion(line, column, left, createExp_Operator(operationType, symbol), right);
      }//se creó el método solo con tal que no esté así explícito en las axn xD, porque en realidad lo único que se hará aquí es crear el objeto y devolverlo :v xD

      function createExp_Operator(type, symbol){
            switch(symbol){
               //ARITMETIC
                  case "+":
                        return new Operator(type, OperatorType.ADD);
                  case "-":
                        return new Operator(type, OperatorType.MINUS);
                  case "*":
                        return new Operator(type, OperatorType.TIMES);
                  case "/":
                        return new Operator(type, OperatorType.DIV);
                  case "%":
                        return new Operator(type, OperatorType.MOD);
                  case "^":                  
                        return new Operator(type, OperatorType.POW);
               //RELATIONAL
                  case "==":
                        return new Operator(type, OperatorType.EQUALS_TO);
                  case "!=":
                        return new Operator(type, OperatorType.DIFERENT);
                  case ">":
                        return new Operator(type, OperatorType.MORE);
                  case "<":
                        return new Operator(type, OperatorType.LESS);
                  case ">=":
                        return new Operator(type, OperatorType.MORE_EQUALS);
                  case "<=":
                        return new Operator(type, OperatorType.LESS_EQUALS);
                  case "~":
                        return new Operator(type, OperatorType.INCERTITUDE);
               //LOGIC
                  case "&&":
                        return new Operator(type, OperatorType.AND);
                  case "||":
                        return new Operator(type, OperatorType.OR);
                  case "|&":
                        return new Operator(type, OperatorType.XOR);
                  case "!":
                        return new Operator(type, OperatorType.NOT);
                  case "()":
                        return new Operator(type, OperatorType.AGRUP);
            }
            return null; //pero nunca se llegará hasta acá xD
      }

      function createExpr_Value(line, column, valueType, content){
            console.log("[S] Function content: EXPR-VALUE [ "+valueType+", "+content+" ]");

            switch(valueType){
                  case "INTEGER"://no lo dejo como number, puesto que si lo hago así, no tendría oportunidad de setear los decimales
                        return new Expresion(line, column, null, new Number(content), null);
                  case "DECIMAL":
                        return new Expresion(line, column, null, new Number(content), null);//para tratarlo como decimal, es que se hará las respectivas revisiones en la parte de la clase Expresión...                   
                  case "CADENA":
                        return new Expresion(line, column, null, new String(content), null);
                  case "BOOLEAN":
                        console.log("boolean content: " + content);
                        console.log("boolean convertion: " + ((content == "true")?true:false));//el new Boolean convierte tb el false a true :v xD
                        return new Expresion(line, column, null, ((content == "true")?true:false), null);
                  case "CHARACTER":
                        return new Expresion(line, column, null, new String(content), null);
                  case "VARIABLE":                        
                        return new Expresion(line, column, null, new Variable(line, column, null, content, null), null);//para este caso el argu para el valor, en realidad será el nombre xD
                  case "INVOCACION":
                        return new Expresion(line, column, null, content, null);//seteo de una vez el content, puesto que la invocación ya fue creada en otra parte...
            }
            return null;//no se llegará aquí, puesto que el tipo siempre será enviado por mí xD, a lo que voy es que será certero jaja xD
      }//Este se utilizará en las producciones de las expr que corresp a valores no a ops obvi xD     
      //fin de los métodos para expresión

      function createInvocation(line, column, invocatedFunction, argumentos){
            console.log("[S] Function content: INVOCATION [ arguments? "+ ((argumentos.length>0)?"T":"F") + " list? "+ isAList+" ]");
            return new Invocacion(line, column, invocatedFunction, argumentos);
      }

      function createMostrar(line, column, stringBase, argumentos){//simi a los de la func... o yo creo que iguales xD
            console.log("[S] Function content: MOSTRAR [arguments? "+ ((argumentos.length>0)?"T":"F") + "list? "+isAList);
            return new Mostrar(line, column, stringBase, argumentos);
      }

      function createDraw_AST(line, column, functionName){
            console.log("[S] Function content: DRAW_AST of "+functionName);
            return new DibujarAST(line, column, functionName);
      }

      function createDraw_EXP(line, column, expression){
            console.log("[S] Function content: DRAW_EXPR");
            return new DibujarEXP(line, column, expression);
      }     

      function createDraw_TS(line, column){
            console.log("[S] Function content: DRAW_TS");
            return new DibujarTS(line, column);
      }//mejor cree 3 para cada uno, puesto que los tipos de param varían y son algo diferentes xD, pero si no es nec, entonces solo los fusionas y luego les indicas su tipo, para que sepa a que obj crear y poor ello devolver xD

      function createBreakPoint(line, column, breakpointType, expr){//solo tendrá valor != null cuando el breakpoint a crear se un return complejo...
            console.log("[S] Function subcontent: BREAKPOINT [ "+breakpointType+((breakpointType == "RETURN" && expr != null)?+"+ expr":""));

            switch(breakpointType){
                  case "RETURN":
                        return new Return(line, column, expr);//si es simple pues recibirá null, sino la expr xD, así que NO PROBLEM jaja xD
                  case "CONTINUE":
                        return new Continue(line, column);
                  case "BREAK":
                        return new Break(line, column);
            }
            return null;//pero no se llegará hasta aquí xD
      }     

      function createFor(line, column, variable, condition, incremento){
            console.log("[S] Function content: FOR");
            return new For(line, column, variable, condition, ((incremento == "++")?1:-1));
      } 

      function createForVar(line, column, variableName, value){//este valor siempre será un entero, por lo que dijo el aux, aunque creo que en os objetos tengo ahí una expr xD
            console.log("[S] Function subcontent: FOR-VAR [ "+variableName+" ]");
            let variable = new Variable(line, column, ContentType.INTEGER, variableName, value);
            console.log("[S] Function subcontent: FOR-VAR -> "+variable);
            console.log(variable);
            return variable;
      }

      function createWhile(line, column, condition){
            console.log("[S] Function content: WHILE");
            return new While(line, column, condition);
      }      

      function createControl_Sentence(line, column, expre){//será null cuando la sent a crear sea else xD
            if(expre == null){
                  console.log("[S] Function content: ELSE");
                  return new Else(line, column);
            }
            console.log("[S] Function content: IF");
            return new If(line, column, expre);
      }                  

      /*function handleLexerError(lexema){
            lexer_error += lexema;
      }*/

      function addLexer_Error(line, column, yytext){
            //se setea lo recolectado en el manejador de errores
            console.log("[L] ERROR: " + lexer_error);
            errorHandler.addMessage(new Error(ErrorType.LEXER, ErrorMessage.LEXER_ERROR,
                     new SourceLocation((line == undefined)?0:line, (column == undefined)?0:column), yytext, clase.getName()));
      }

      function addParser_Error(errorType, line, column, yytext, errorMessage){
            //se setea lo recolectado en el manejador de errores
            console.log("[S] ERROR: " + lexer_error);
            errorHandler.addMessage(new Error(errorType, errorMessage,
                     new SourceLocation((line == undefined)?0:line, (column == undefined)?0:column), yytext, clase.getName()));
      }
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"ranges":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:console.log("[L] especial: NL"); return 107;
break;
case 1:console.log("[L] especial: SANGRIA"); return 8;
break;
case 2:/*ignored*/
break;
case 3:/*ignored*/
break;
case 4:/*ignored*/
break;
case 5:console.log("[L] S_comentario: "+ yy_.yytext);
break;
case 6:console.log("[L] M_comentario: "+ yy_.yytext);
break;
case 7:console.log("[L] reservada: IMPORT"); return 14;
break;
case 8:console.log("[L] reservada: INCERTEZA"); return 18;
break;
case 9:console.log("[L] reservada: PRINCIPAL"); return 44;
break;
case 10:console.log("[L] reservada: INT"); return 33;
break;
case 11:console.log("[L] reservada: DOUBLE"); return 34;
break;
case 12:console.log("[L] reservada: STRING"); return 35;
break;
case 13:console.log("[L] reservada: BOOLEAN"); return 36;
break;
case 14:console.log("[L] reservada: CHAR"); return 37;
break;
case 15:console.log("[L] reservada: VOID"); return 43;
break;
case 16:console.log("[L] reservada: SI"); return 105;
break;
case 17:console.log("[L] reservada: SINO"); return 106;
break;
case 18:console.log("[L] reservada: PARA"); return 100;
break;
case 19:console.log("[L] reservada: MIENTRAS"); return 104;
break;
case 20:console.log("[L] reservada: DETENER"); return 99;
break;
case 21:console.log("[L] reservada: CONTINUAR"); return 98;
break;
case 22:console.log("[L] reservada: MOSTRAR"); return 92;
break;
case 23:console.log("[L] reservada: DRAW_AST"); return 94;
break;
case 24:console.log("[L] reservada: DRAW_EXP"); return 95;
break;
case 25:console.log("[L] reservada: DRAW_TS"); return 96;
break;
case 26:console.log("[L] reservada: TRUE"); return 89;
break;
case 27:console.log("[L] reservada: FALSE"); return 90;
break;
case 28:console.log("[L] reservada: ++"); return 103;
break;
case 29:console.log("[L] reservada: --"); return 103;
break;
case 30:console.log("[L] reservada: +"); return 57;
break;
case 31:console.log("[L] reservada: -"); return 59;
break;
case 32:console.log("[L] reservada: *"); return 60;
break;
case 33:console.log("[L] reservada: /"); return 62;
break;
case 34:console.log("[L] reservada: %"); return 63;
break;
case 35:console.log("[L] reservada: ^"); return 65;
break;
case 36:console.log("[L] reservada: =="); return 67;
break;
case 37:console.log("[L] reservada: !="); return 69;
break;
case 38:console.log("[L] reservada: <="); return 72;
break;
case 39:console.log("[L] reservada: >="); return 73;
break;
case 40:console.log("[L] reservada: <"); return 70;
break;
case 41:console.log("[L] reservada: >"); return 71;
break;
case 42:console.log("[L] reservada: ~"); return 74;
break;
case 43:console.log("[L] reservada: &&"); return 79;
break;
case 44:console.log("[L] reservada: ||"); return 75;
break;
case 45:console.log("[L] reservada: |&"); return 77;
break;
case 46:console.log("[L] reservada: !"); return 81;
break;
case 47:console.log("[L] reservada: ("); return 39;
break;
case 48:console.log("[L] reservada: )"); return 41;
break;
case 49:console.log("[L] reservada: :"); return 42;
break;
case 50:console.log("[L] reservada: ="); return 55;
break;
case 51:console.log("[L] reservada: ,"); return 32;
break;
case 52:console.log("[L] reservada: ;"); return 102;
break;
case 53:console.log("[L] reservada: RETORNO"); return 97;
break;
case 54:console.log("[L] reservada: ."); return 16;
break;
case 55:console.log("[L] reservada: crl"); return 17;
break;
case 56:console.log("[L] ER: CADENA "+ (yy_.yytext.substring(1, yy_.yyleng -1)));
                                                                             yy_.yytext = yy_.yytext.substring(1, yy_.yyleng -1);
                                                                             return 85;
break;
case 57:console.log("[L] ER: ID "+console.log(yy_.yytext)); return 15;
break;
case 58:console.log("[L] ER: DEC"); return 84;
break;
case 59:console.log("[L] ER: INT"); return 83;
break;
case 60:console.log("[L] ER: CHAR"); return 87;
break;
case 61:console.log("[L] EOF"); return 5;
break;
case 62: addLexer_Error(yy_.yylloc.first_line, yy_.yylloc.first_column, yy_.yytext); 
break;
}
},
rules: [/^(?:(\n|\r|\v)+)/,/^(?:\t+)/,/^(?:\s)/,/^(?:\r)/,/^(?: )/,/^(?:!![^\n]*)/,/^(?:(''')([^']*)('''))/,/^(?:Importar\b)/,/^(?:Incerteza\b)/,/^(?:Principal\b)/,/^(?:Int\b)/,/^(?:Double\b)/,/^(?:String\b)/,/^(?:Boolean\b)/,/^(?:Char\b)/,/^(?:Void\b)/,/^(?:Si\b)/,/^(?:Sino\b)/,/^(?:Para\b)/,/^(?:Mientras\b)/,/^(?:Detener\b)/,/^(?:Continuar\b)/,/^(?:Mostrar\b)/,/^(?:DibujarAST\b)/,/^(?:DibujarEXP\b)/,/^(?:DibujarTS\b)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:\+\+)/,/^(?:--)/,/^(?:\+)/,/^(?:-)/,/^(?:\*)/,/^(?:\/)/,/^(?:%)/,/^(?:\^)/,/^(?:==)/,/^(?:!=)/,/^(?:<=)/,/^(?:>=)/,/^(?:<)/,/^(?:>)/,/^(?:~)/,/^(?:&&)/,/^(?:\|\|)/,/^(?:\|&)/,/^(?:!)/,/^(?:\()/,/^(?:\))/,/^(?::)/,/^(?:=)/,/^(?:,)/,/^(?:;)/,/^(?:Retorno\b)/,/^(?:\.)/,/^(?:crl\b)/,/^(?:("[^\"]*"))/,/^(?:(_|\$|([a-zA-Z\u00f1\u00d1]))(_|\$|([a-zA-Z\u00f1\u00d1])|[0-9])*)/,/^(?:[0-9]+(\.[0-9]+))/,/^(?:[0-9]+)/,/^(?:'([a-zA-Z\u00f1\u00d1])|\s')/,/^(?:$)/,/^(?:.)/],
conditions: {"ERROR":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62],"inclusive":true},"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = CRLGrammar;
exports.Parser = CRLGrammar.Parser;
exports.parse = function () { return CRLGrammar.parse.apply(CRLGrammar, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}