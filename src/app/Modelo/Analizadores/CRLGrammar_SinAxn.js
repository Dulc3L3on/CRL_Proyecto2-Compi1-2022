/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var CRLGrammar_SinAxn = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,12],$V1=[1,9],$V2=[1,20],$V3=[1,21],$V4=[1,22],$V5=[1,23],$V6=[1,24],$V7=[1,19],$V8=[1,14],$V9=[30,31,32,33,34,39,43],$Va=[5,30,31,32,33,34,39,43],$Vb=[11,16,30,31,32,33,34,39,43],$Vc=[1,52],$Vd=[1,49],$Ve=[1,35],$Vf=[1,41],$Vg=[1,43],$Vh=[1,44],$Vi=[1,45],$Vj=[1,47],$Vk=[1,50],$Vl=[1,51],$Vm=[1,85],$Vn=[1,86],$Vo=[15,29,37,55,57,100],$Vp=[1,87],$Vq=[1,88],$Vr=[1,89],$Vs=[15,29,37,55,57,58,60,61,100],$Vt=[15,29,37,55,57,58,60,61,63,100],$Vu=[1,92],$Vv=[1,93],$Vw=[1,94],$Vx=[1,95],$Vy=[1,96],$Vz=[1,97],$VA=[1,98],$VB=[15,29,37,55,57,58,60,61,63,65,67,68,69,70,71,72,100],$VC=[1,99],$VD=[15,29,37,55,57,58,60,61,63,65,67,68,69,70,71,72,73,100],$VE=[1,100],$VF=[15,29,37,55,57,58,60,61,63,65,67,68,69,70,71,72,73,75,100],$VG=[1,101],$VH=[15,29,37,55,57,58,60,61,63,65,67,68,69,70,71,72,73,75,77,100],$VI=[1,104],$VJ=[1,114],$VK=[15,29,53],$VL=[2,23],$VM=[2,33],$VN=[1,163],$VO=[29,37];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"inicio":3,"clase":4,"EOF":5,"header":6,"content":7,"imports":8,"incerteza":9,"import":10,"IMPORT":11,"ID":12,".":13,"CRL":14,"NEW_LINE":15,"INCERTEZA":16,"expression":17,"sentences":18,"class_content":19,"function_content":20,"class_content_elements":21,"declaracion_var_global":22,"declaracion_funcion":23,"declaracion_var":24,"content_type":25,"creacion_vars":26,"asignation_value":27,"var_list":28,",":29,"INT":30,"DOUBLE":31,"STRING":32,"BOOLEAN":33,"CHAR":34,"(":35,"params":36,")":37,":":38,"VOID":39,"MAIN":40,"params_list":41,"param":42,"SANGRIA":43,"function_sentence":44,"only_sentence":45,"loop_sentence":46,"control_sentence":47,"asignacion_var":48,"invocacion":49,"mostrar":50,"dibujar":51,"breakpoints":52,"=":53,"expr":54,"+":55,"expr2":56,"-":57,"*":58,"expr3":59,"/":60,"%":61,"expr4":62,"^":63,"expr5":64,"==":65,"expr6":66,"!=":67,"<":68,">":69,"<=":70,">=":71,"~":72,"||":73,"expr7":74,"|&":75,"expr8":76,"&&":77,"expr9":78,"!":79,"expr10":80,"INTEGER":81,"DECIMAL":82,"CADENA":83,"booleano":84,"CHARACTER":85,"contenido_var":86,"TRUE":87,"FALSE":88,"argumentos":89,"MOSTRAR":90,"contenido_asignacion":91,"DRAW_AST":92,"DRAW_EXP":93,"DRAW_TS":94,"return":95,"CONTINUAR":96,"DETENER":97,"PARA":98,"for_var":99,";":100,"INCREMENTO":101,"MIENTRAS":102,"SI":103,"SINO":104,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",11:"IMPORT",12:"ID",13:".",14:"CRL",15:"NEW_LINE",16:"INCERTEZA",29:",",30:"INT",31:"DOUBLE",32:"STRING",33:"BOOLEAN",34:"CHAR",35:"(",37:")",38:":",39:"VOID",40:"MAIN",43:"SANGRIA",53:"=",55:"+",57:"-",58:"*",60:"/",61:"%",63:"^",65:"==",67:"!=",68:"<",69:">",70:"<=",71:">=",72:"~",73:"||",75:"|&",77:"&&",79:"!",81:"INTEGER",82:"DECIMAL",83:"CADENA",85:"CHARACTER",87:"TRUE",88:"FALSE",90:"MOSTRAR",92:"DRAW_AST",93:"DRAW_EXP",94:"DRAW_TS",95:"return",96:"CONTINUAR",97:"DETENER",98:"PARA",100:";",101:"INCREMENTO",102:"MIENTRAS",103:"SI",104:"SINO"},
productions_: [0,[3,2],[4,2],[4,1],[6,2],[6,1],[6,1],[8,2],[8,1],[10,5],[9,3],[7,2],[7,1],[18,1],[18,1],[19,2],[21,1],[21,1],[22,1],[24,3],[24,2],[26,1],[28,3],[28,1],[25,1],[25,1],[25,1],[25,1],[25,1],[23,6],[23,6],[23,5],[36,1],[36,0],[41,3],[41,1],[42,2],[20,3],[44,1],[44,1],[44,1],[45,1],[45,1],[45,1],[45,1],[45,1],[45,1],[48,2],[27,2],[17,1],[54,3],[54,3],[54,1],[56,3],[56,3],[56,3],[56,1],[59,3],[59,1],[62,2],[62,1],[64,3],[64,3],[64,3],[64,3],[64,3],[64,3],[64,3],[64,1],[66,3],[66,1],[74,3],[74,1],[76,3],[76,1],[78,2],[78,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,3],[84,1],[84,1],[86,1],[86,1],[49,4],[49,3],[50,5],[91,2],[91,0],[89,3],[89,1],[51,4],[51,4],[51,3],[52,1],[52,2],[52,1],[52,1],[46,7],[46,5],[99,4],[47,5],[47,2]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
console.log("---Parser process terminated---");
break;
case 2:
console.log("[S] Structure: Header + Content");
break;
case 3:
console.log("[S] Structure: Only Body");
break;
case 4:
console.log("[S] Header content: IMPORT + INCERTITUDE");
break;
case 5:
console.log("[S] Header content: IMPORT");
break;
case 6:
console.log("[S] Header content: INCERTITUDE");
break;
case 7:
console.log("[S] Header content: +1 IMPORT");
break;
case 8:
console.log("[S] Header content: 1st IMPORT");
break;
case 9:
addImport($$[$0-3]);
break;
case 10:
addIncertitude($$[$0-1]);
break;
case 11:
console.log("[S] Class content: +1 sentence");
break;
case 12:
console.log("[S] Class content: 1st sentence");
break;
case 13:
console.log("[S] Class complete content: CLASS- content added");
break;
case 14:
console.log("[S] Class complete content: FUN- content added");
break;
case 16:
 addClassContent(false); 
break;
case 17:
 addClassContent(true); 
break;
case 18:
console.log("[S] Class content: "+ $$[$0].lenght +"GLOBAL var created"); 
break;
case 19:
 createVarDeclaration($$[$0-2], $$[$0-1], $$[$0]); 
break;
case 20:
 createVarDeclaration($$[$0-1], $$[$0], null); 
break;
case 21:
 this.$ = ((isAList)?"var list":"var");
break;
case 22: case 34: case 93:
 isAList = true; 
break;
case 23: case 35: case 94:
 isAList = false; 
break;
case 24:
 this.$ = "INT"; 
break;
case 25:
 this.$ = "DOUBLE"; 
break;
case 26:
 this.$ = "STRING"; 
break;
case 27:
 this.$ = "BOOLEAN"; 
break;
case 28:
 this.$ = "CHAR"; 
break;
case 29:
 createFunction("COMPLEX", $$[$0-5], $$[$0-4], $$[$0-2]); 
break;
case 30:
 createFunction("SIMPLE", $$[$0-5], $$[$0-4], $$[$0-2]); 
break;
case 31:
 createFunction("MAIN", $$[$0-4], $$[$0-3], "without params"); 
break;
case 32:
 this.$ = ((isAList)?" param list":" param"); 
break;
case 33:
 this.$ = "without params"; 
break;
case 36:
 createParam($$[$0-1], $$[$0]); 
break;
case 37:
 addFunctionContent(getHierarchy($$[$0-2]), $$[$0-1]); 
break;
case 38:
 isADirective = true;
                                                          this.$ = "sentence"; 
break;
case 39:
 isADirective = false;
                                                          this.$ = "loop"; 
break;
case 40:
 isADirective = false;
                                                          this.$ = "control"; 
break;
case 41: case 42: case 43: case 44: case 45: case 46: case 84: case 85:
 this.$ = $$[$0]; 
break;
case 47:
 createAsignation($$[$0-1]); 
break;
case 50: case 51: case 53: case 54: case 55: case 57: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 69: case 71: case 73:
 createExpr_Operation($$[$0-1]); 
break;
case 59:
 createExpr_Operation("uminus"); 
break;
case 75:
 createExpr_Operation($$[$0]); 
break;
case 77:
 createExpr_Value("INTEGER", $$[$0]); 
break;
case 78:
 createExpr_Value("DECIMAL", $$[$0]); 
break;
case 79:
 createExpr_Value("CADENA", $$[$0]); 
break;
case 80:
 createExpr_Value("BOOLEAN", $$[$0]); 
break;
case 81:
 createExpr_Value("CHARACTER", $$[$0]); 
break;
case 83:
 createExpr_Operation("()"); 
break;
case 86:
 createExpr_Value("VARIABLE", $$[$0]); 
break;
case 87:
 createExpr_Value("INVOCACIÓN", null); 
break;
case 88:
 createInvocation($$[$0-3], true); 
break;
case 89:
 createInvocation($$[$0-2], false); 
break;
case 90:
 createMostrar($$[$0-2], $$[$0-1]); 
break;
case 91:
 this.$ = true; 
break;
case 92:
 this.$ = false; 
break;
case 95:
 createDraw_AST($$[$0-1]); 
break;
case 96:
 createDraw_EXP(); 
break;
case 97:
 createDraw_TS(); 
break;
case 98:
 createBreakPoint("RETURN", null); 
break;
case 99:
 createBreakPoint("RETURN", $$[$0]); 
break;
case 100:
 createBreakPoint("CONTINUE", null); 
break;
case 101:
 createBreakPoint("BREAK", null); 
break;
case 102:
 createFor(); 
break;
case 103:
 createWhile(); 
break;
case 104:
 createForVar($$[$0-2]); 
break;
case 105:
 createControl_Sentence(true); 
break;
case 106:
 createControl_Sentence(false); 
break;
}
},
table: [{3:1,4:2,6:3,7:4,8:5,9:6,10:8,11:$V0,16:$V1,18:7,19:10,20:11,21:13,22:15,23:16,24:17,25:18,30:$V2,31:$V3,32:$V4,33:$V5,34:$V6,39:$V7,43:$V8},{1:[3]},{5:[1,25]},{7:26,18:7,19:10,20:11,21:13,22:15,23:16,24:17,25:18,30:$V2,31:$V3,32:$V4,33:$V5,34:$V6,39:$V7,43:$V8},{5:[2,3],18:27,19:10,20:11,21:13,22:15,23:16,24:17,25:18,30:$V2,31:$V3,32:$V4,33:$V5,34:$V6,39:$V7,43:$V8},o($V9,[2,5],{9:28,10:29,11:$V0,16:$V1}),o($V9,[2,6]),o($Va,[2,12]),o($Vb,[2,8]),{12:$Vc,17:30,35:$Vd,49:53,54:31,56:32,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},o($Va,[2,13]),o($Va,[2,14]),{12:[1,54]},{15:[1,55]},{12:[1,71],24:60,25:70,30:$V2,31:$V3,32:$V4,33:$V5,34:$V6,44:56,45:57,46:58,47:59,48:61,49:62,50:63,51:64,52:65,90:[1,72],92:[1,73],93:[1,74],94:[1,75],95:[1,76],96:[1,77],97:[1,78],98:[1,66],102:[1,67],103:[1,68],104:[1,69]},{15:[2,16]},{15:[2,17]},{15:[2,18]},{12:[1,79],26:80,28:81},{12:[1,82],40:[1,83]},{12:[2,24]},{12:[2,25]},{12:[2,26]},{12:[2,27]},{12:[2,28]},{1:[2,1]},{5:[2,2],18:27,19:10,20:11,21:13,22:15,23:16,24:17,25:18,30:$V2,31:$V3,32:$V4,33:$V5,34:$V6,39:$V7,43:$V8},o($Va,[2,11]),o($V9,[2,4]),o($Vb,[2,7]),{15:[1,84]},o([15,29,37,100],[2,49],{55:$Vm,57:$Vn}),o($Vo,[2,52],{58:$Vp,60:$Vq,61:$Vr}),o($Vs,[2,56]),o($Vs,[2,58],{63:[1,90]}),{12:$Vc,35:$Vd,49:53,64:91,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},o($Vt,[2,60],{65:$Vu,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA}),o($VB,[2,68],{73:$VC}),o($VD,[2,70],{75:$VE}),o($VF,[2,72],{77:$VG}),o($VH,[2,74]),{12:$Vc,35:$Vd,49:53,80:102,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},o($VH,[2,76]),o($VH,[2,77]),o($VH,[2,78]),o($VH,[2,79]),o($VH,[2,80]),o($VH,[2,81]),o($VH,[2,82]),{12:$Vc,35:$Vd,49:53,54:103,56:32,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},o($VH,[2,84]),o($VH,[2,85]),o($VH,[2,86],{35:$VI}),o($VH,[2,87]),{13:[1,105]},o($Va,[2,15]),{15:[1,106]},{15:[2,38]},{15:[2,39]},{15:[2,40]},{15:[2,41]},{15:[2,42]},{15:[2,43]},{15:[2,44]},{15:[2,45]},{15:[2,46]},{30:[1,108],99:107},{35:[1,109]},{35:[1,110]},{38:[1,111]},{12:[1,112],26:80,28:81},{27:113,35:$VI,53:$VJ},{35:[1,115]},{35:[1,116]},{35:[1,117]},{35:[1,118]},{12:$Vc,15:[2,98],17:119,35:$Vd,49:53,54:31,56:32,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{15:[2,100]},{15:[2,101]},o($VK,$VL,{35:[1,120]}),{15:[2,20],27:121,53:$VJ},o([15,53],[2,21],{29:[1,122]}),{35:[1,123]},{35:[1,124]},o($V9,[2,10]),{12:$Vc,35:$Vd,49:53,56:125,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,56:126,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,57:$Ve,59:127,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,57:$Ve,59:128,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,57:$Ve,59:129,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,57:$Ve,59:130,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},o($Vt,[2,59],{65:$Vu,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA}),{12:$Vc,35:$Vd,49:53,66:131,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,66:132,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,66:133,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,66:134,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,66:135,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,66:136,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,66:137,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,74:138,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,76:139,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,35:$Vd,49:53,78:140,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},o($VH,[2,75]),{37:[1,141],55:$Vm,57:$Vn},{12:$Vc,17:144,35:$Vd,37:[1,143],49:53,54:31,56:32,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl,89:142},{14:[1,145]},o($Va,[2,37]),{100:[1,146]},{12:[1,147]},{12:$Vc,17:148,35:$Vd,49:53,54:31,56:32,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{12:$Vc,17:149,35:$Vd,49:53,54:31,56:32,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{15:[2,106]},o($VK,$VL),{15:[2,47]},{12:$Vc,17:150,35:$Vd,49:53,54:31,56:32,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{83:[1,151]},{12:[1,152]},{12:$Vc,17:153,35:$Vd,49:53,54:31,56:32,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{37:[1,154]},{15:[2,99]},{25:158,30:$V2,31:$V3,32:$V4,33:$V5,34:$V6,36:155,37:$VM,41:156,42:157},{15:[2,19]},{12:[1,159]},{25:158,30:$V2,31:$V3,32:$V4,33:$V5,34:$V6,36:160,37:$VM,41:156,42:157},{37:[1,161]},o($Vo,[2,50],{58:$Vp,60:$Vq,61:$Vr}),o($Vo,[2,51],{58:$Vp,60:$Vq,61:$Vr}),o($Vs,[2,53]),o($Vs,[2,54]),o($Vs,[2,55]),o($Vs,[2,57]),o($VB,[2,61],{73:$VC}),o($VB,[2,62],{73:$VC}),o($VB,[2,63],{73:$VC}),o($VB,[2,64],{73:$VC}),o($VB,[2,65],{73:$VC}),o($VB,[2,66],{73:$VC}),o($VB,[2,67],{73:$VC}),o($VD,[2,69],{75:$VE}),o($VF,[2,71],{77:$VG}),o($VH,[2,73]),o($VH,[2,83]),{29:$VN,37:[1,162]},o($VH,[2,89]),o($VO,[2,94]),{15:[1,164]},{12:$Vc,17:165,35:$Vd,49:53,54:31,56:32,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},{53:[1,166]},{37:[1,167]},{37:[1,168]},{15:[2,48]},{29:[1,170],37:[2,92],91:169},{37:[1,171]},{37:[1,172]},{15:[2,97]},{37:[1,173]},{29:[1,174],37:[2,32]},o($VO,[2,35]),{12:[1,175]},o($VK,[2,22]),{37:[1,176]},{38:[1,177]},o($VH,[2,88]),{12:$Vc,17:178,35:$Vd,49:53,54:31,56:32,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl},o($Vb,[2,9]),{100:[1,179]},{81:[1,180]},{38:[1,181]},{38:[1,182]},{37:[1,183]},{12:$Vc,17:144,35:$Vd,49:53,54:31,56:32,57:$Ve,59:33,62:34,64:36,66:37,74:38,76:39,78:40,79:$Vf,80:42,81:$Vg,82:$Vh,83:$Vi,84:46,85:$Vj,86:48,87:$Vk,88:$Vl,89:184},{15:[2,95]},{15:[2,96]},{38:[1,185]},{25:158,30:$V2,31:$V3,32:$V4,33:$V5,34:$V6,42:186},o($VO,[2,36]),{38:[1,187]},{15:[2,31]},o($VO,[2,93]),{101:[1,188]},{100:[2,104]},{15:[2,103]},{15:[2,105]},{15:[2,90]},{29:$VN,37:[2,91]},{15:[2,29]},o($VO,[2,34]),{15:[2,30]},{38:[1,189]},{15:[2,102]}],
defaultActions: {15:[2,16],16:[2,17],17:[2,18],20:[2,24],21:[2,25],22:[2,26],23:[2,27],24:[2,28],25:[2,1],57:[2,38],58:[2,39],59:[2,40],60:[2,41],61:[2,42],62:[2,43],63:[2,44],64:[2,45],65:[2,46],77:[2,100],78:[2,101],111:[2,106],113:[2,47],119:[2,99],121:[2,19],150:[2,48],154:[2,97],171:[2,95],172:[2,96],177:[2,31],180:[2,104],181:[2,103],182:[2,105],183:[2,90],185:[2,29],187:[2,30],189:[2,102]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
      

      
      let isADirective;
      let isAList;

   //HEADERS
      function addImport(importClassName){
            console.log("[S] Header content: IMPORT [ "+ importClassName+" ]");

            /*if(activeFileHandler.isExistFile(importClassName)){
                  if(!activeFileHandler.isMainFile(importClassName)){
                        console.log("import: "+ importClassName+" added");
                        clase.addImport(new Import(importClassName));
                  }else{
                        //Se add el error, puesto que el archivo Main no tendría porque poder importarse, ya que eso no impediría que se pudiera invocar el método Main de nuevo, y así provocar un error por quedarse enciclado...
                  }                  
            }else{
                  //Se add el error al manejador de errores, el cual se encarga de llevar el conteo y addlos de una vez a la consola...
            }*/
      }

      function addIncertitude(/*expression*/){
            //Simplemente se debe crear el obj y addlo al globalContent (lo cual se puede hacer sin problema, pruesto que para que pudiera ser seteada al contenido se hizo que heredara de Directive...), puesto que la revisión profunda [con respecto a la exp], se hace en la clase Incert...
            console.log("[S] Header content: INCERTITUDE");
            //clase.addGlobalContent(new Incertitude(expresion));
      }

  //CLASS CONTENT

      function getHierarchy(sangria){
            let lexemma = sangria.charAt();//si no funciona usa split y "" nada xD
            console.log("SANGRIA: "+lexema.lenght);

            return lexema.lenght;
      }

      function addClassContent(isAFunction){
            if(isAFunction){
                  console.log("[S] Class content: FUNCTION");
            }else{
                  console.log("[S] Class content: VAR DECLARATION");
            }
            

            /*if(theFunction == null){//no reviso si el listado está vacío, porque bien podría ser que el dato que se envió fue el de una declaración, pero que... iba a decir que no contenga vars, pero en ese caso tendría que haber sucedido un error para que llegue vacía la lista...
                  hierarchyStack.reduceStack();//se hace aquí puesto que el for es para add cada var que se colocó en una misma línea de creación

                  for(let index = 0; index < declaratedVars.lenght; index++){                        
                        declaratedVars[index].setScope(0);
                        declaratedVars[index].setFather(clase);
                        clase.addGlobalContent(declaratedVars[index]);
                  }
            }else{
                  //la función ya tiene por defecto scope = 0, entonces no hay que hacer eso aquí
                  //tb ya tiene seteado su respectivo padre xD
                  clase.addGlobalContent(theFunction);//que se quede, puesto que encaja con las axn del stack xD
                  hierarchyStack.addFunction(theFunction);
            }*/
      }//por la RP que contiene ambos tipos de contenido, se me ocurrió que quizá podría hacer el seteo de cada contenido, por medio de difernetes métodos, además como el proceso de seteo varía, puesto que en uno va directo al padre y en el otro directo a la func que está al ini de la pila o dir a la pila, entonces... xD      

      function addFunctionContent(scope, content){
            content.setScope(scope);

            if(isADirective){
                  console.log("[S] Function content: SANGRIA [" + content + "directive on "+scope +" level]");
                  //hierarchyStack.addLocalDirective(content);
            }else{
                  console.log("[S] Function content: SANGRIA [" + content + "sentence on "+scope +" level]");
                  //hierarchyStack.addLocalContainer(content);
            }//no tengo que resetear la var isADirective, puesto que no se va a llegar a la RP que invoca a este método, sin haber caido en la axn que setea esta var xD
      }

      function createVarDeclaration(type, declaratedElements, asignatedValue){//Este último puede ser null, puesto que no es obligatorio que especifiquen este valor...
            console.log("[S] Global content: DECLARATION [ "+declaratedElements+((asignatedValue != null)?" + expr":"")+ " ]");
            
            /*let declaratedVars = [];//new Array<Variable_Declaration>()

            for(let index = 0; index < varList.lenght; index++){
                  declaratedVars.push(type, varList[index], asignatedValue);
            }
            return declaratedVars;*/
      }//sin importar que sea G o L, puesto que esto se determina en prod más arriba de la RP en donde se crea el obj xD      

      function createFunction(functionType, returnType, name, params){
            switch(functionType){
                  case "SIMPLE":
                        console.log("[S] Global content: S_FUNCTION [ "+returnType +", "+name+", "+params);
                        //return new Void_Function(clase, returnType, name, params);
                  case "COMPLEX":
                        console.log("[S] Global content: C_FUNCTION [ "+returnType +", "+name+", "+params);
                        //return new Complex_Function(clase, returnType, name, params);
                  case "MAIN":
                        console.log("[S] Global content: M_FUNCTION [ "+returnType +", "+name);
                        //return new Void_Function(clase);
            }
            //return null;//pero nunca se va a caer acá...
      }//LISTO

      function createParam(type, name){
            console.log("[S] Function sub-content: PARAM ["+type+", "+name+"]");
            //return new Variable(type, name);
      }      

 //FUNCTION CONTENT

      function createAsignation(name){
            console.log("[S] Function content: ASIGNATION [ "+name+" + expr ]");
            //return new Asignacion(name, expr);
      }

   //EXPRESSIONS
      function createExpr_Operation(symbol){//ya sea la root o no
            console.log("[S] Function content: EXPR-OPERATION [ "+symbol+" ]");
            //return new Expression(left, createExp_Operator(operationType, symbol), right);
      }//se creó el método solo con tal que no esté así explícito en las axn xD, porque en realidad lo único que se hará aquí es crear el objeto y devolverlo :v xD      

      function createExpr_Value(valueType, content){
            if(valueType == "INVOCACION"){
                  console.log("[S] Function content: EXPR-VALUE [ "+valueType+" ]");
            }else{
                  console.log("[S] Function content: EXPR-VALUE [ "+valueType+", "+content+" ]");
            }
      }
      //fin de los métodos para expresión

      function createInvocation(invocatedFunction, argumentos){
            if(argumentos){
                  console.log("[S] Function content: INVOCATION [ arguments? "+argumentos+ " list? "+ isAList+" ]");
            }else{
                  console.log("[S] Function content: INVOCATION [ arguments? "+argumentos+" ]");
            }            
            //return new Invocacion(invocatedFunction, argumentos);
      }

      function createMostrar(stringBase, argumentos){//simi a los de la func... o yo creo que iguales xD
            if(argumentos){
                  console.log("[S] Function content: MOSTRAR [arguments? "+ argumentos + "list? "+isAList);
            }else{
                  console.log("[S] Function content: MOSTRAR [arguments? "+ argumentos);
            }            
            //return new Mostrar(stringBase, argumentos);
      }

      function createDraw_AST(functionName){
            console.log("[S] Function content: DRAW_AST of "+functionName);
            //return new DibujarAST(functionName);
      }

      function createDraw_EXP(){
            console.log("[S] Function content: DRAW_EXPR");
            //return new DibujarEXP(expression);
      }     

      function createDraw_TS(){
            console.log("[S] Function content: DRAW_AST");
            //return new DibujarTS();
      }//mejor cree 3 para cada uno, puesto que los tipos de param varían y son algo diferentes xD, pero si no es nec, entonces solo los fusionas y luego les indicas su tipo, para que sepa a que obj crear y poor ello devolver xD

      function createBreakPoint(breakpointType, expr){//solo tendrá valor != null cuando el breakpoint a crear se un return complejo...
            console.log("[S] Function subcontent: BREAKPOINT [ "+breakpointType+((breakpointType == "RETURN" && expr != null)?+"+ expr":""));
      }     

      function createFor(){
            console.log("[S] Function content: FOR");
            //return new For(variable, condition, incremento);
      } 

      function createForVar(variableName){//este valor siempre será un entero, por lo que dijo el aux, aunque creo que en os objetos tengo ahí una expr xD
            console.log("[S] Function subcontent: FOR-VAR [ "+variableName+" ]");
            //return new Variable(ContentType.INTEGER, variableName, value);
      }

      function createWhile(condition){
            console.log("[S] Function content: WHILE");
            //return new While(condition);
      }      

      function createControl_Sentence(expre){//será null cuando la sent a crear sea else xD
            if(!expre){
                  console.log("[S] Function content: ELSE");
                  //return new Else();
            }
            console.log("[S] Function content: IF");
            //return new If(expre);
      }                  

      function handleLexerError(lexema){
            lexer_error += lexema;
      }

      function addError(line, column){
            //se setea lo recolectado en el manejador de errores
            console.log("[L] ERROR: " + lexer_error);
            lexer_error = "";//Se limpia la variable, para dejar paso libre a los errores que se vayan a hallar xD            
      }
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/**/
break;
case 1:/**/
break;
case 2:/*ignore*//*{console.log("[L] comentario: "+ yy_.yytext);}*/
break;
case 3:this.begin('COMMENT');
break;
case 4:console.log("[L] comentario"); this.popState();
break;
case 5:/*ignore*/
break;
case 6:console.log("[L] reservada: IMPORT"); return 11;
break;
case 7:console.log("[L] reservada: INCERT"); return 16;
break;
case 8:console.log("[L] reservada: PRINCI"); return 40;
break;
case 9:console.log("[L] reservada: INT"); return 30;
break;
case 10:console.log("[L] reservada: DOUBLE"); return 31;
break;
case 11:console.log("[L] reservada: STRING"); return 32;
break;
case 12:console.log("[L] reservada: BOOLEAN"); return 33;
break;
case 13:console.log("[L] reservada: CHAR"); return 34;
break;
case 14:console.log("[L] reservada: VOID"); return 39;
break;
case 15:console.log("[L] reservada: SI"); return 103;
break;
case 16:console.log("[L] reservada: SINO"); return 104;
break;
case 17:console.log("[L] reservada: PARA"); return 98;
break;
case 18:console.log("[L] reservada: MIENTRAS"); return 102;
break;
case 19:console.log("[L] reservada: DETENER"); return 97;
break;
case 20:console.log("[L] reservada: CONTINUAR"); return 96;
break;
case 21:console.log("[L] reservada: MOSTRAR"); return 90;
break;
case 22:console.log("[L] reservada: DRAW_AST"); return 92;
break;
case 23:console.log("[L] reservada: DRAW_EXP"); return 93;
break;
case 24:console.log("[L] reservada: DRAW_ES"); return 94;
break;
case 25:console.log("[L] reservada: TRUE"); return 87;
break;
case 26:console.log("[L] reservada: FALSE"); return 88;
break;
case 27:console.log("[L] reservada: +"); return 55;
break;
case 28:console.log("[L] reservada: -"); return 57;
break;
case 29:console.log("[L] reservada: *"); return 58;
break;
case 30:console.log("[L] reservada: /"); return 60;
break;
case 31:console.log("[L] reservada: %"); return 61;
break;
case 32:console.log("[L] reservada: ^"); return 63;
break;
case 33:console.log("[L] reservada: =="); return 65;
break;
case 34:console.log("[L] reservada: !="); return 67;
break;
case 35:console.log("[L] reservada: <"); return 68;
break;
case 36:console.log("[L] reservada: >"); return 69;
break;
case 37:console.log("[L] reservada: <="); return 70;
break;
case 38:console.log("[L] reservada: >="); return 71;
break;
case 39:console.log("[L] reservada: ~"); return 72;
break;
case 40:console.log("[L] reservada: &&"); return 77;
break;
case 41:console.log("[L] reservada: ||"); return 73;
break;
case 42:console.log("[L] reservada: |&"); return 75;
break;
case 43:console.log("[L] reservada: !"); return 79;
break;
case 44:console.log("[L] reservada: ++"); return 101;
break;
case 45:console.log("[L] reservada: --"); return 101;
break;
case 46:console.log("[L] reservada: ("); return 35;
break;
case 47:console.log("[L] reservada: )"); return 37;
break;
case 48:console.log("[L] reservada: :"); return 38;
break;
case 49:console.log("[L] reservada: ="); return 53;
break;
case 50:console.log("[L] reservada: ,"); return 29;
break;
case 51:console.log("[L] reservada: ;"); return 100;
break;
case 52:console.log("[L] reservada: RETORNO"); return 'RETORNO';
break;
case 53:console.log("[L] especial: NL"); return 15;
break;
case 54:console.log("[L] especial: SANGRIA"); return 43;
break;
case 55:console.log("[L] ER: INT"); return 81;
break;
case 56:console.log("[L] ER: DEC"); return 82;
break;
case 57:console.log("[L] ER: CHAR"); return 85;
break;
case 58:console.log("[L] reservada: ."); return 13;
break;
case 59:console.log("[L] reservada: .crl"); return 14;
break;
case 60:console.log("[L] ER: ID"); return 12;
break;
case 61:this.begin('SSTRING');
break;
case 62:console.log("ER: CADENA: "+yy_.yytext);return 83;
break;
case 63:this.yybegin('ERROR');
break;
case 64:this.yybegin('ERROR');
break;
case 65:this.popState();
break;
case 66:console.log("[L] EOF"); return 5;
break;
case 67:addError(yy_.yylloc.first_line, yy_.yylloc.first_column); this.popState();
break;
case 68:handleLexerError(); this.yybegin('ERROR');
break;
}
},
rules: [/^(?:\s)/,/^(?:\r)/,/^(?:!!.*)/,/^(?:''')/,/^(?:''')/,/^(?:.)/,/^(?:Importar\b)/,/^(?:Incerteza\b)/,/^(?:Principal\b)/,/^(?:Int\b)/,/^(?:Double\b)/,/^(?:String\b)/,/^(?:Boolean\b)/,/^(?:Char\b)/,/^(?:Void\b)/,/^(?:Si\b)/,/^(?:Sino\b)/,/^(?:Para\b)/,/^(?:Mientras\b)/,/^(?:Detener\b)/,/^(?:Continuar\b)/,/^(?:Mostrar\b)/,/^(?:DibujarAST\b)/,/^(?:DibujarEXP\b)/,/^(?:DibujarTS\b)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:\+)/,/^(?:-)/,/^(?:\*)/,/^(?:\/)/,/^(?:%)/,/^(?:\^)/,/^(?:==)/,/^(?:!=)/,/^(?:<)/,/^(?:>)/,/^(?:<=)/,/^(?:>=)/,/^(?:~)/,/^(?:&&)/,/^(?:\|\|)/,/^(?:\|&)/,/^(?:!)/,/^(?:\+\+)/,/^(?:--)/,/^(?:\()/,/^(?:\))/,/^(?::)/,/^(?:=)/,/^(?:,)/,/^(?:;)/,/^(?:Retorno\b)/,/^(?:\n+)/,/^(?:\t+)/,/^(?:[0-9]+\b)/,/^(?:[0-9]+(\.[0-9]+)?\b)/,/^(?:'([a-zA-Z\u00f1\u00d1])|\s')/,/^(?:\.)/,/^(?:crl\b)/,/^(?:(\$|([a-zA-Z\u00f1\u00d1]))|(_|\$|([a-zA-Z\u00f1\u00d1]))(_|\$|([a-zA-Z\u00f1\u00d1])|[0-9])+)/,/^(?:["])/,/^(?:[^"\n]*)/,/^(?:[\n])/,/^(?:$)/,/^(?:["])/,/^(?:$)/,/^(?:\s+)/,/^(?:[.])/],
conditions: {"COMMENT":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,66,68],"inclusive":true},"SSTRING":{"rules":[0,1,2,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,68],"inclusive":true},"ERROR":{"rules":[0,1,2,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,66,67,68],"inclusive":true},"INITIAL":{"rules":[0,1,2,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,66,68],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = CRLGrammar_SinAxn;
exports.Parser = CRLGrammar_SinAxn.Parser;
exports.parse = function () { return CRLGrammar_SinAxn.parse.apply(CRLGrammar_SinAxn, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}